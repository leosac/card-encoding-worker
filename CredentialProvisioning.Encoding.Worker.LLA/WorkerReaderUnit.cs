using Leosac.CredentialProvisioning.Encoding.LLA;
using Leosac.CredentialProvisioning.Encoding.Worker.Contracts;

namespace Leosac.CredentialProvisioning.Encoding.Worker.LLA
{
    /// <summary>
    /// Worker Reader Unit implementation.
    /// </summary>
    /// <remarks>
    /// We are wrapping asynchronous methods into synchronous ones... THIS SHOULD BE AVOIDED.
    /// But as we are overriding LLA objects generated by SWIG, it is a required workaround for now.
    /// </remarks>
    public class WorkerReaderUnit : LibLogicalAccess.Reader.PCSCReaderUnit
    {
        IReaderClient _readerClient;
        WorkerDataTransport? _dataTransport;
        bool _disposed;
        ChipContext? _chipContext;

        public WorkerReaderUnit(IReaderClient readerClient, string alias) : base("")
        {
            _readerClient = readerClient;
            Alias = alias;
            _dataTransport = new WorkerDataTransport(this);
        }

        public string Alias { get; private set; }

        public IReaderClient GetReaderClient()
        {
            return _readerClient;
        }

        public override bool connectToReader()
        {
            base.connectToSAM();
            // Do nothing else, automatically managed by the client
            return true;
        }

        public override bool waitInsertion(uint maxwait)
        {
            var task = _readerClient.WaitCardInsertion(Alias, maxwait);
            task.Wait();
            var inserted = task.Result;
            if (inserted)
            {
                // limit communication to the unique Reader session here ?
                // We want to create appropriate "reader proxy" on LLA at that time, based on the reader name...
                // We also copy the SAM reader unit and SAM chip instances from base to proxy for now until next release of LLA
                var samru = getSAMReaderUnit();
                var samchip = getSAMChip();
                setName(getConnectedName());
                if (samru != null)
                {
                    setSAMReaderUnit(samru);
                }
                if (samchip != null)
                {
                    setSAMChip(samchip);
                }
            }
            return inserted;
        }

        public override bool connect()
        {
            var task = _readerClient.ConnectToCard(Alias);
            task.Wait();
            var ret = task.Result;
            if (ret && _chipContext == null)
            {
                var ctxTask = CreateChipContext();
                ctxTask.Wait();
                _chipContext = ctxTask.Result;
            }
            return ret;
        }

        protected async Task<ChipContext> CreateChipContext()
        {
            var context = new ChipContext();
            context.ContextId = await _readerClient.CreateCardContext(Alias);
            context.CardType = await _readerClient.GetCardType(Alias, context.ContextId);
            context.ChipIdentifier = await _readerClient.GetChipIdentifier(Alias, context.ContextId);
            return context;
        }

        public override bool isConnected()
        {
            var task = _readerClient.IsConnectedToCard(Alias);
            task.Wait();
            return task.Result;
        }

        public override void disconnect()
        {
            var task = _readerClient.DisconnectFromCard(Alias);
            task.Wait();
            if (_chipContext != null)
            {
                _chipContext = null;
            }
        }

        public byte[] sendRawCmd(byte[] data)
        {
            if (_chipContext == null)
                return null;

            var task = _readerClient.SendRawCmd(Alias, _chipContext.ContextId, data);
            task.Wait();
            return task.Result;
        }

        public override bool waitRemoval(uint maxwait)
        {
            var task = _readerClient.WaitCardRemoval(Alias, maxwait);
            task.Wait();
            return task.Result;
        }

        public override void disconnectFromReader()
        {
            base.disconnectFromSAM();
            // Do nothing else, automatically managed by the client
        }

        public override string getName()
        {
            return getConnectedName();
        }

        public override string getConnectedName()
        {
            var task = _readerClient.GetDeviceName(Alias);
            task.Wait();
            return task.Result;
        }

        public override void setCardType(string cardType)
        {
            var task = _readerClient.SetCardType(Alias, cardType);
            task.Wait();
        }

        public override LibLogicalAccess.Chip createChip(string type, LibLogicalAccess.ByteVector identifier)
        {
            // Because of SWIG issue calling base method implementation, we call the overloaded createChip method and assign manually the chip identifier by ourselves
            var chip = base.createChip(type);
            if (chip != null)
            {
                chip.setChipIdentifier(identifier);
                // Todo: check, and init identifier crypto on chip creation
                if (chip.getGenericCardType() == "DESFire")
                {
                    (chip as LibLogicalAccess.Card.DESFireChip)?.getCrypto().setIdentifier(identifier);
                }
                var cmd = chip.getCommands();
                if (cmd != null)
                {
                    var rca = cmd.getReaderCardAdapter();
                    if (rca != null)
                    {
                        rca.setDataTransport(_dataTransport);
                    }
                }
            }

            return chip;
        }

        public override LibLogicalAccess.ChipVector getChipList()
        {
            return new LibLogicalAccess.ChipVector
            {
                getSingleChip()
            };
        }

        public override LibLogicalAccess.Chip getSingleChip()
        {
            if (_chipContext == null)
                return null;

            return createChip(_chipContext.CardType, new LibLogicalAccess.ByteVector(Convert.FromHexString(_chipContext.ChipIdentifier)));
        }

        public override void Dispose()
        {
            Dispose(true);
            //base.Dispose();
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;

            if (disposing)
            {
                //release resources
                _dataTransport = null;
            }

            _disposed = true;
        }
    }
}
