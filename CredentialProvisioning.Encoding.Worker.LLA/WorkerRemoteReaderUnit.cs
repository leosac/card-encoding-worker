using Leosac.CredentialProvisioning.Encoding.Worker.Contracts;

namespace Leosac.CredentialProvisioning.Encoding.Worker.LLA
{
    /// <summary>
    /// Worker Reader Unit implementation.
    /// </summary>
    /// <remarks>
    /// We are wrapping asynchronous methods into synchronous ones... THIS SHOULD BE AVOIDED.
    /// But as we are overriding LLA objects generated by SWIG, it is a required workaround for now.
    /// </remarks>
#pragma warning disable IDE1006 // Naming Styles
    public class WorkerRemoteReaderUnit : LibLogicalAccess.Reader.PCSCReaderUnit
    {
        protected readonly IReaderClient _readerClient;
        protected readonly Version? _apiVersion;
        protected readonly bool _waitRemoval;
        WorkerRemoteDataTransport? _dataTransport;
        bool _disposed;
        string? _cardContext;
        LibLogicalAccess.Chip? _cachedChip;

        public WorkerRemoteReaderUnit(IReaderClient readerClient, string apiVersion, string alias, bool waitRemoval = true) : base("")
        {
            Version.TryParse(apiVersion, out _apiVersion);
            _readerClient = readerClient;
            Alias = alias;
            _waitRemoval = waitRemoval;
            _dataTransport = new WorkerRemoteDataTransport(this);
            _cachedChip = null;
        }

        public string Alias { get; private set; }

        public IReaderClient GetReaderClient()
        {
            return _readerClient;
        }

        public override bool connectToReader()
        {
            var task = _readerClient.ConnectToReader(Alias);
            task.Wait();
            if (task.Result)
            {
                setDataTransport(_dataTransport);
                var rca = getDefaultReaderCardAdapter();
                rca.setDataTransport(_dataTransport);
                setDefaultReaderCardAdapter(rca);
                rca = getDefaultReaderCardAdapter();

                base.connectToSAM();
            }
            return task.Result;
        }

        public override bool waitInsertion(uint maxwait)
        {
            var inserted = false;
            Task.Run(async () =>
            {
                // limit communication to the unique Reader session here ?
                // We want to create appropriate "reader proxy" on LLA at that time, based on the reader name...
                // We also copy the SAM reader unit and SAM chip instances from base to proxy for now until next release of LLA
                var samru = getSAMReaderUnit();
                var samchip = getSAMChip();

                inserted = await _readerClient.WaitCardInsertion(Alias, maxwait);
                if (inserted)
                {
                    setName(getConnectedName());
                    if (samru != null)
                    {
                        setSAMReaderUnit(samru);
                    }
                    if (samchip != null)
                    {
                        setSAMChip(samchip);
                    }
                }
            }).Wait();
            return inserted;
        }

        public override bool connect()
        {
            var task = _readerClient.ConnectToCard(Alias);
            task.Wait();
            var ret = task.Result;
            if (ret && _cardContext == null)
            {
                var ctxTask = _readerClient.CreateCardContext(Alias);
                ctxTask.Wait();
                _cardContext = ctxTask.Result;
            }
            return ret;
        }

        public override bool isConnected()
        {
            var task = _readerClient.IsConnectedToCard(Alias);
            task.Wait();
            return task.Result;
        }

        public override void disconnect()
        {
            var task = _readerClient.DisconnectFromCard(Alias);
            task.Wait();
            if (_cardContext != null)
            {
                _cardContext = null;
            }
            if (_cachedChip != null)
            {
                _cachedChip = null;
            }
        }

        public override bool reconnect(int action)
        {
            if (_apiVersion != null && _apiVersion >= new Version("1.1.0"))
            {
                var task = _readerClient.ReconnectToCard(Alias, action);
                task.Wait();
                return task.Result;
            }
            else
            {
                return base.reconnect(action);
            }
        }

        public byte[] sendRawCmd(byte[] data)
        {
            if (_cardContext == null)
            {
#pragma warning disable CS8603 // Possible null reference return.
                return null;
#pragma warning restore CS8603 // Possible null reference return.
            }

            var task = _readerClient.SendRawCmd(Alias, _cardContext, data);
            task.Wait();
            return task.Result;
        }

        public override bool waitRemoval(uint maxwait)
        {
            var task = _readerClient.WaitCardRemoval(Alias, _waitRemoval ? maxwait : 1);
            task.Wait();
            return !_waitRemoval || task.Result;
        }

        public override void disconnectFromReader()
        {
            base.disconnectFromSAM();
            // Do nothing else, automatically managed by the client
            var task = _readerClient.DisconnectFromReader(Alias);
            task.Wait();
        }

        public override string getName()
        {
            return getConnectedName();
        }

        public override string getConnectedName()
        {
            var task = _readerClient.GetDeviceName(Alias);
            task.Wait();
            return task.Result;
        }

        public override void setCardType(string cardType)
        {
            var task = _readerClient.SetCardType(Alias, cardType);
            task.Wait();
        }

        public override LibLogicalAccess.Chip createChip(string type, LibLogicalAccess.ByteVector identifier)
        {
            // Because of SWIG issue calling base method implementation, we call the overloaded createChip method and assign manually the chip identifier by ourselves
            var chip = base.createChip(type);
            if (chip != null)
            {
                chip.setChipIdentifier(identifier);
                // Todo: check, and init identifier crypto on chip creation
                if (chip.getGenericCardType() == "DESFire")
                {
                    var dfchip = chip as LibLogicalAccess.Card.DESFireChip;
                    if (dfchip != null)
                    {
                        dfchip.getCrypto().setIdentifier(identifier);
                        dfchip.setHasRealUID(IsRealUid(identifier, "DESFire"));
                    }
                }
                var cmd = chip.getCommands();
                if (cmd != null)
                {
                    // TODO: fix this, it shouldn't be required
                    var rca = cmd.getReaderCardAdapter();
                    rca?.setDataTransport(getDefaultReaderCardAdapter().getDataTransport());
                }
            }

#pragma warning disable CS8603 // Possible null reference return.
            return chip;
#pragma warning restore CS8603 // Possible null reference return.
        }

        public static bool IsRealUid(LibLogicalAccess.ByteVector csn, string? cardType = null)
        {
            return !(csn == null || csn.Count < 1 || csn[0] == 0x08 || (!string.IsNullOrEmpty(cardType) && cardType == "DESFire" && csn[0] == 0x80));
        }

        public override LibLogicalAccess.ChipVector getChipList()
        {
            return
            [
                getSingleChip()
            ];
        }

        public override LibLogicalAccess.Chip getSingleChip()
        {
            if (_cachedChip == null)
            {
                if (_cardContext == null)
                {
#pragma warning disable CS8603 // Possible null reference return.
                    return null;
#pragma warning restore CS8603 // Possible null reference return.
                }

                var ctTask = _readerClient.GetCardType(Alias, _cardContext);
                ctTask.Wait();
                var ct = ctTask.Result;
                var csnTask = _readerClient.GetChipIdentifier(Alias, _cardContext);
                csnTask.Wait();
                var csn = csnTask.Result;

                _cachedChip = createChip(ct, new LibLogicalAccess.ByteVector(Convert.FromHexString(csn)));
            }
            return _cachedChip;
        }

        protected override void Dispose(bool disposing)
        {
            if (_disposed)
                return;

            base.Dispose(disposing);

            if (disposing)
            {
                //release resources
                _dataTransport = null;
            }

            _disposed = true;
        }
    }
#pragma warning restore IDE1006 // Naming Styles
}
