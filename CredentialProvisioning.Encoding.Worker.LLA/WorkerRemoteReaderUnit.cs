using Leosac.CredentialProvisioning.Encoding.Worker.Contracts;

namespace Leosac.CredentialProvisioning.Encoding.Worker.LLA
{
    /// <summary>
    /// Worker Reader Unit implementation.
    /// </summary>
    /// <remarks>
    /// We are wrapping asynchronous methods into synchronous ones... THIS SHOULD BE AVOIDED.
    /// But as we are overriding LLA objects generated by SWIG, it is a required workaround for now.
    /// </remarks>
    public class WorkerRemoteReaderUnit : LibLogicalAccess.Reader.PCSCReaderUnit
    {
        IReaderClient _readerClient;
        WorkerRemoteDataTransport? _dataTransport;
        bool _disposed;
        bool _waitRemoval;
        string? _cardContext;

        public WorkerRemoteReaderUnit(IReaderClient readerClient, string alias, bool waitRemoval = true) : base("")
        {
            _readerClient = readerClient;
            Alias = alias;
            _waitRemoval = waitRemoval;
            _dataTransport = new WorkerRemoteDataTransport(this);
        }

        public string Alias { get; private set; }

        public IReaderClient GetReaderClient()
        {
            return _readerClient;
        }

        public override bool connectToReader()
        {
            base.connectToSAM();
            // Do nothing else, automatically managed by the client
            return true;
        }

        public override bool waitInsertion(uint maxwait)
        {
            var inserted = false;
            Task.Run(async () =>
            {
                inserted = await _readerClient.WaitCardInsertion(Alias, maxwait);
                if (inserted)
                {
                    // limit communication to the unique Reader session here ?
                    // We want to create appropriate "reader proxy" on LLA at that time, based on the reader name...
                    // We also copy the SAM reader unit and SAM chip instances from base to proxy for now until next release of LLA
                    var samru = getSAMReaderUnit();
                    var samchip = getSAMChip();
                    setName(getConnectedName());
                    if (samru != null)
                    {
                        setSAMReaderUnit(samru);
                    }
                    if (samchip != null)
                    {
                        setSAMChip(samchip);
                    }
                }
            }).Wait();
            return inserted;
        }

        public override bool connect()
        {
            var task = _readerClient.ConnectToCard(Alias);
            task.Wait();
            var ret = task.Result;
            if (ret && _cardContext == null)
            {
                var ctxTask = _readerClient.CreateCardContext(Alias);
                ctxTask.Wait();
                _cardContext = ctxTask.Result;
            }
            return ret;
        }

        public override bool isConnected()
        {
            var task = _readerClient.IsConnectedToCard(Alias);
            task.Wait();
            return task.Result;
        }

        public override void disconnect()
        {
            var task = _readerClient.DisconnectFromCard(Alias);
            task.Wait();
            if (_cardContext != null)
            {
                _cardContext = null;
            }
        }

        public byte[] sendRawCmd(byte[] data)
        {
            if (_cardContext == null)
                return null;

            var task = _readerClient.SendRawCmd(Alias, _cardContext, data);
            task.Wait();
            return task.Result;
        }

        public override bool waitRemoval(uint maxwait)
        {
            var task = _readerClient.WaitCardRemoval(Alias, _waitRemoval ? maxwait : 1);
            task.Wait();
            return _waitRemoval ? task.Result : true;
        }

        public override void disconnectFromReader()
        {
            base.disconnectFromSAM();
            // Do nothing else, automatically managed by the client
        }

        public override string getName()
        {
            return getConnectedName();
        }

        public override string getConnectedName()
        {
            var task = _readerClient.GetDeviceName(Alias);
            task.Wait();
            return task.Result;
        }

        public override void setCardType(string cardType)
        {
            var task = _readerClient.SetCardType(Alias, cardType);
            task.Wait();
        }

        public override LibLogicalAccess.Chip createChip(string type, LibLogicalAccess.ByteVector identifier)
        {
            // Because of SWIG issue calling base method implementation, we call the overloaded createChip method and assign manually the chip identifier by ourselves
            var chip = base.createChip(type);
            if (chip != null)
            {
                chip.setChipIdentifier(identifier);
                // Todo: check, and init identifier crypto on chip creation
                if (chip.getGenericCardType() == "DESFire")
                {
                    (chip as LibLogicalAccess.Card.DESFireChip)?.getCrypto().setIdentifier(identifier);
                }
                var cmd = chip.getCommands();
                if (cmd != null)
                {
                    var rca = cmd.getReaderCardAdapter();
                    if (rca != null)
                    {
                        rca.setDataTransport(_dataTransport);
                    }
                }
            }

            return chip;
        }

        public override LibLogicalAccess.ChipVector getChipList()
        {
            return new LibLogicalAccess.ChipVector
            {
                getSingleChip()
            };
        }

        public override LibLogicalAccess.Chip getSingleChip()
        {
            if (_cardContext == null)
                return null;

            var ctTask = _readerClient.GetCardType(Alias, _cardContext);
            ctTask.Wait();
            var ct = ctTask.Result;
            var csnTask = _readerClient.GetChipIdentifier(Alias, _cardContext);
            csnTask.Wait();
            var csn = csnTask.Result;

            return createChip(ct, new LibLogicalAccess.ByteVector(Convert.FromHexString(csn)));
        }

        public override void Dispose()
        {
            Dispose(true);
            //base.Dispose();
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;

            if (disposing)
            {
                //release resources
                _dataTransport = null;
            }

            _disposed = true;
        }
    }
}
